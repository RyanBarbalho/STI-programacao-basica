"""
Sistema de Dicas Inteligentes usando LLM
Gera dicas personalizadas baseadas no erro do aluno
"""

import os
import json
import requests
from typing import Dict, List, Optional

# Carregar vari√°veis de ambiente do arquivo .env se existir
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

class DicasInteligentes:
    """
    Classe para gerar dicas inteligentes usando LLM
    """

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv('OPENAI_API_KEY')
        self.base_url = "https://api.openai.com/v1/chat/completions"

    def gerar_dica_erro_compilacao(self, codigo: str, erro: str, tipo_problema: str) -> str:
        """
        Gera dica espec√≠fica para erro de compila√ß√£o
        """
        # Tentar usar API primeiro
        prompt = f"""
        Voc√™ √© um professor experiente de programa√ß√£o C. O aluno cometeu um erro de compila√ß√£o.

        TIPO DE PROBLEMA: {tipo_problema}
        C√ìDIGO DO ALUNO:
        {codigo}

        ERRO DE COMPILA√á√ÉO:
        {erro}

        Gere uma dica espec√≠fica e √∫til (m√°ximo 2 frases) que ajude o aluno a corrigir o erro.
        Seja direto e espec√≠fico. N√£o d√™ a resposta completa, apenas uma dica.

        Responda apenas com a dica, sem formata√ß√£o adicional.
        """

        dica_api = self._chamar_llm(prompt)

        # Se a API falhou, usar an√°lise local
        if dica_api == self._dica_padrao():
            return self._gerar_dica_inteligente_local(codigo, "compilacao", {"erro": erro})

        return dica_api

    def gerar_dica_resposta_errada(self, codigo: str, entrada: str, saida_esperada: str,
                                  saida_obtida: str, tipo_problema: str) -> str:
        """
        Gera dica espec√≠fica para resposta incorreta
        """
        # Tentar usar API primeiro
        prompt = f"""
        Voc√™ √© um professor experiente de programa√ß√£o C. O aluno resolveu o problema, mas a sa√≠da est√° incorreta.

        TIPO DE PROBLEMA: {tipo_problema}
        C√ìDIGO DO ALUNO:
        {codigo}

        ENTRADA: {entrada if entrada else "(sem entrada)"}
        SA√çDA ESPERADA: {saida_esperada}
        SA√çDA OBTIDA: {saida_obtida if saida_obtida else "(sa√≠da vazia)"}

        Analise a diferen√ßa entre a sa√≠da esperada e a obtida. Gere uma dica espec√≠fica (m√°ximo 2 frases)
        que ajude o aluno a identificar e corrigir o problema.

        Seja direto e espec√≠fico. N√£o d√™ a resposta completa, apenas uma dica.

        Responda apenas com a dica, sem formata√ß√£o adicional.
        """

        dica_api = self._chamar_llm(prompt)

        # Se a API falhou, usar an√°lise local
        if dica_api == self._dica_padrao():
            contexto = {
                "entrada": entrada,
                "saida_esperada": saida_esperada,
                "saida_obtida": saida_obtida
            }
            return self._gerar_dica_inteligente_local(codigo, "resposta_errada", contexto)

        return dica_api

    def gerar_dica_conceitos_faltantes(self, codigo: str, conceitos_faltantes: List[str],
                                     tipo_problema: str, enunciado: str) -> str:
        """
        Gera dica para conceitos faltantes
        """
        # Tentar usar API primeiro
        conceitos_str = ", ".join(conceitos_faltantes)

        prompt = f"""
        Voc√™ √© um professor experiente de programa√ß√£o C. O aluno n√£o usou alguns conceitos necess√°rios.

        TIPO DE PROBLEMA: {tipo_problema}
        ENUNCIADO: {enunciado}
        C√ìDIGO DO ALUNO:
        {codigo}

        CONCEITOS FALTANTES: {conceitos_str}

        Gere uma dica espec√≠fica (m√°ximo 2 frases) que oriente o aluno sobre quais conceitos usar
        para resolver o problema corretamente.

        Seja direto e espec√≠fico. N√£o d√™ a resposta completa, apenas uma dica.

        Responda apenas com a dica, sem formata√ß√£o adicional.
        """

        dica_api = self._chamar_llm(prompt)

        # Se a API falhou, usar an√°lise local
        if dica_api == self._dica_padrao():
            contexto = {"conceitos_faltantes": conceitos_faltantes}
            return self._gerar_dica_inteligente_local(codigo, "conceitos_faltantes", contexto)

        return dica_api

    def gerar_dica_geral(self, codigo: str, tipo_problema: str, enunciado: str, pergunta: str = "") -> str:
        """
        Gera dica geral para o problema ou responde perguntas espec√≠ficas
        """
        if pergunta:
            # Se h√° uma pergunta espec√≠fica, responder a ela
            prompt = f"""
            Voc√™ √© um professor experiente de programa√ß√£o C. O aluno fez uma pergunta sobre um problema.

            TIPO DE PROBLEMA: {tipo_problema}
            ENUNCIADO: {enunciado}
            C√ìDIGO DO ALUNO:
            {codigo}

            PERGUNTA DO ALUNO: {pergunta}

            Responda √† pergunta do aluno de forma clara e espec√≠fica (m√°ximo 3 frases).
            Seja direto e √∫til. Se a pergunta for sobre n√£o entender o enunciado, explique de forma simples.

            Responda apenas com a resposta, sem formata√ß√£o adicional.
            """
        else:
            # Dica geral (comportamento original)
            prompt = f"""
            Voc√™ √© um professor experiente de programa√ß√£o C. O aluno est√° tentando resolver um problema.

            TIPO DE PROBLEMA: {tipo_problema}
            ENUNCIADO: {enunciado}
            C√ìDIGO DO ALUNO:
            {codigo}

            Gere uma dica geral e motivacional (m√°ximo 2 frases) que ajude o aluno a pensar sobre
            como resolver o problema.

            Seja encorajador e direto. N√£o d√™ a resposta completa, apenas uma orienta√ß√£o.

            Responda apenas com a dica, sem formata√ß√£o adicional.
            """

        dica_api = self._chamar_llm(prompt)

        # Se a API falhou, usar an√°lise local
        if dica_api == self._dica_padrao():
            contexto = {"pergunta": pergunta}
            return self._gerar_dica_inteligente_local(codigo, "geral", contexto)

        return dica_api

    def _chamar_llm(self, prompt: str) -> str:
        """
        Chama a API da OpenAI para gerar dicas
        """
        if not self.api_key:
            return self._dica_padrao()

        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }

            data = {
                "model": "gpt-3.5-turbo",
                "messages": [
                    {"role": "system", "content": "Voc√™ √© um professor de programa√ß√£o C experiente e paciente."},
                    {"role": "user", "content": prompt}
                ],
                "max_tokens": 150,
                "temperature": 0.7
            }

            response = requests.post(self.base_url, headers=headers, json=data, timeout=10)

            if response.status_code == 200:
                result = response.json()
                return result['choices'][0]['message']['content'].strip()
            else:
                return self._dica_padrao()

        except Exception as e:
            print(f"Erro ao chamar LLM: {e}")
            return self._dica_padrao()

    def _dica_padrao(self) -> str:
        """
        Retorna dicas padr√£o quando a LLM n√£o est√° dispon√≠vel
        """
        dicas = [
            "üí° Revise o c√≥digo e verifique se todos os conceitos necess√°rios est√£o sendo usados.",
            "üîç Compare sua sa√≠da com a esperada e identifique as diferen√ßas.",
            "üìö Lembre-se de usar as estruturas de controle apropriadas para este tipo de problema.",
            "‚úÖ Verifique se a sintaxe est√° correta e se todas as chaves est√£o balanceadas.",
            "üéØ Foque nos conceitos principais deste tipo de problema."
        ]
        import random
        return random.choice(dicas)

    def _gerar_dica_inteligente_local(self, codigo: str, tipo_erro: str, contexto: dict) -> str:
        """
        Gera dicas inteligentes usando an√°lise local do c√≥digo
        """
        codigo_lower = codigo.lower()

        # Verificar se h√° uma pergunta espec√≠fica no contexto
        pergunta = contexto.get('pergunta', '').lower() if contexto else ''

        # Responder perguntas conceituais comuns
        if pergunta:
            if 'estrutura de controle' in pergunta:
                return "Uma estrutura de controle em C √© um comando como if, else, while ou for que controla o fluxo de execu√ß√£o do programa."
            elif 'printf' in pergunta:
                return "printf() √© uma fun√ß√£o em C usada para exibir texto na tela. Exemplo: printf('Ol√° mundo!');"
            elif 'scanf' in pergunta:
                return "scanf() √© uma fun√ß√£o em C usada para ler dados do teclado. Exemplo: scanf('%d', &numero);"
            elif 'enunciado' in pergunta or 'n√£o entendi' in pergunta:
                return "O enunciado descreve o que seu programa deve fazer. Leia com aten√ß√£o e identifique o que precisa ser feito."
            elif 'main' in pergunta:
                return "main() √© a fun√ß√£o principal em C. Todo programa deve ter uma fun√ß√£o main() que √© onde a execu√ß√£o come√ßa."
            elif 'include' in pergunta:
                return "#include √© usado para incluir bibliotecas. stdio.h √© a biblioteca padr√£o para entrada/sa√≠da."
            elif 'vari√°vel' in pergunta:
                return "Uma vari√°vel √© um espa√ßo na mem√≥ria para armazenar dados. Em C, declare com: int nome;"
            elif 'loop' in pergunta or 'repeti√ß√£o' in pergunta:
                return "Loops repetem a√ß√µes. Use while() para repetir enquanto uma condi√ß√£o for verdadeira, ou for() para repetir um n√∫mero espec√≠fico de vezes."
            elif 'condicional' in pergunta or 'if' in pergunta:
                return "Estruturas condicionais (if/else) permitem tomar decis√µes no programa baseado em condi√ß√µes."

        if tipo_erro == "compilacao":
            # An√°lise espec√≠fica de erros de compila√ß√£o
            if "'" in codigo and '"' not in codigo:
                return "üí° Voc√™ est√° usando aspas simples (') para strings. Em C, use aspas duplas (\") para strings."

            if "printf" in codigo_lower and ";" not in codigo:
                return "üí° Lembre-se de terminar os comandos com ponto e v√≠rgula (;)."

            if "main" not in codigo_lower:
                return "üí° Todo programa C precisa ter uma fun√ß√£o main()."

            if "#include" not in codigo_lower:
                return "üí° N√£o esque√ßa de incluir as bibliotecas necess√°rias com #include."

            return "üí° Verifique a sintaxe do c√≥digo. Erros comuns: chaves desbalanceadas, ponto e v√≠rgula faltando, aspas incorretas."

        elif tipo_erro == "resposta_errada":
            entrada = contexto.get('entrada', '')
            saida_esperada = contexto.get('saida_esperada', '')
            saida_obtida = contexto.get('saida_obtida', '')

            # An√°lise de diferen√ßas espec√≠ficas
            if saida_esperada and saida_obtida:
                if len(saida_esperada) != len(saida_obtida):
                    return f"üí° Sua sa√≠da tem {len(saida_obtida)} caracteres, mas deveria ter {len(saida_esperada)}. Verifique espa√ßos e pontua√ß√£o."

                if saida_esperada.lower() == saida_obtida.lower():
                    return "üí° A sa√≠da est√° correta, mas verifique mai√∫sculas/min√∫sculas e pontua√ß√£o."

                if not saida_obtida:
                    return "üí° Sua sa√≠da est√° vazia. Verifique se est√° usando printf() corretamente."

            return "üí° Compare sua sa√≠da com a esperada. Verifique espa√ßos, pontua√ß√£o e formata√ß√£o."

        elif tipo_erro == "conceitos_faltantes":
            conceitos = contexto.get('conceitos_faltantes', [])

            dicas_especificas = []
            for conceito in conceitos:
                if "printf" in conceito.lower():
                    dicas_especificas.append("Use printf() para exibir texto na tela")
                elif "scanf" in conceito.lower():
                    dicas_especificas.append("Use scanf() para ler dados do teclado")
                elif "if" in conceito.lower():
                    dicas_especificas.append("Use if/else para tomar decis√µes no programa")
                elif "while" in conceito.lower() or "for" in conceito.lower():
                    dicas_especificas.append("Use while ou for para repetir a√ß√µes")
                elif "vetor" in conceito.lower() or "array" in conceito.lower():
                    dicas_especificas.append("Use arrays para armazenar m√∫ltiplos valores")
                elif "fun√ß√£o" in conceito.lower():
                    dicas_especificas.append("Crie fun√ß√µes para organizar seu c√≥digo")

            if dicas_especificas:
                return f"üí° Para este problema, voc√™ precisa: {', '.join(dicas_especificas)}."

            return "üí° Revise os conceitos necess√°rios para este tipo de problema."

        return "üí° Analise o c√≥digo e identifique o que precisa ser corrigido."


# Fun√ß√£o de conveni√™ncia para uso r√°pido
def gerar_dica_erro_compilacao(codigo: str, erro: str, tipo_problema: str) -> str:
    """Fun√ß√£o de conveni√™ncia para gerar dica de erro de compila√ß√£o"""
    dicas = DicasInteligentes()
    return dicas.gerar_dica_erro_compilacao(codigo, erro, tipo_problema)

def gerar_dica_resposta_errada(codigo: str, entrada: str, saida_esperada: str,
                              saida_obtida: str, tipo_problema: str) -> str:
    """Fun√ß√£o de conveni√™ncia para gerar dica de resposta incorreta"""
    dicas = DicasInteligentes()
    return dicas.gerar_dica_resposta_errada(codigo, entrada, saida_esperada, saida_obtida, tipo_problema)

def gerar_dica_conceitos_faltantes(codigo: str, conceitos_faltantes: List[str],
                                 tipo_problema: str, enunciado: str) -> str:
    """Fun√ß√£o de conveni√™ncia para gerar dica de conceitos faltantes"""
    dicas = DicasInteligentes()
    return dicas.gerar_dica_conceitos_faltantes(codigo, conceitos_faltantes, tipo_problema, enunciado)